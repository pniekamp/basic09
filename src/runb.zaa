import std.stdio;
import std.env;
import sys.path;
import basic.parser;
import basic.compiler;
import basic.formatter;
import basic.sys as syslib;
import termios;
import aargh;
import diag;

struct opts
{
  #[arg(free, required, help="source file")]
  std::string file;

  #[arg(free, help="arguments")]
  std::vector<std::string> args;

  #[arg(flag, help="display this help and exit")]
  bool help = false;

  opts() = default;
  ~opts() = default;
}

fn main() -> int
{
  var opts = aargh::parse<opts>(std::env::args);

  if (opts.help || opts.file.empty)
  {
    std::puts("\n");
    std::print("Basic09 interpreter version 0.2");
    
    aargh::usage<opts>();

    return 0;
  }

  termios::ansi_on(1);
  
  try
  {
    var parse = basic::parse_from_file(opts.file);

    if (!parse)
    {
      var diagnostic = diag::diagnostic();

      diagnostic.loc = std::format("{}:{}", parse.fail.line, parse.fail.column);
      diagnostic.message = std::meta::enumerator_name(parse.error);
      diagnostic.source = diag::source_file(opts.file);
      diagnostic.add_label(parse.pass.position, parse.fail.position - parse.pass.position, diagnostic.message);

      std::fprint(std::stderr, diagnostic);
    }

    var vm = basic::machine();
    syslib::initialise(&mut vm);

    for (var &procedure : parse.procedures)
    {
      var compile = basic::compile(procedure);

      if (!compile)
      {
        std::fprint(std::stderr, "runb: ", compile.error);

        continue;
      }

      vm.load(&move compile.procedure);
    }

    var mainproc = std::to_lowercase(sys::path_view(opts.file).stem);

    for (var &[name, procedure] : vm.procedures)
    {
      if (std::to_lowercase(name) == mainproc)
        mainproc = name;
    }

    var src = std::format("PROCEDURE REPL\nRUN {}", mainproc);
    
    if (!opts.args.empty)
    {
      src.append("(");
      
      for (var &arg : opts.args)
      {
        src.append("\"", arg, "\"");
        
        if (&arg != &opts.args.back)
          src.append(",");
      }
      
      src.append(")");
    }
    
    src.append("\n");
    
    var repl = basic::parse_from_string(src);

    if (!repl)
      std::fprint(std::stderr, "runb: ", cast<basic::errc>(repl.error));

    var compile = basic::compile(repl.procedures[0]);

    if (!compile)
      std::fprint(std::stderr, "runb: ", cast<basic::errc>(compile.error));

    if (var rc = vm.run(compile.procedure); !rc)
      std::fprint(std::stderr, "runb: ", cast<basic::errc>(-cast<i32>(rc)));
  }
  catch (std::error rc)
  {
    std::fprint(std::stderr, "runb: ", rc);
  }
  
  return 0;
}